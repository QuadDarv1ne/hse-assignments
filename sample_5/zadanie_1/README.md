# Решение задачи коммивояжера с использованием стека и DFS

Этот проект реализует задачу коммивояжера (`TSP`, `Traveling Salesman Problem`) с помощью поиска в глубину (`DFS`), организованного с использованием `абстрактного типа данных` (АТД) «стек».

## Описание

Задача коммивояжера заключается в нахождении кратчайшего пути, который проходит через все узлы графа ровно один раз и возвращается в начальную точку.

Этот код использует поиск в глубину для исчерпывающего перебора всех возможных путей в графе.

### Особенности

- Реализован собственный класс `Stack` для управления стеком.
- Решение поддерживает графы, заданные в виде матрицы смежности.
- Подходит для небольших графов из-за экспоненциальной сложности.

## Требования

- Python 3.7+

## Использование

### Структура проекта

- Основной файл: `tsp_dfs_stack.py`
- Пример данных задаётся в самом коде.

### Запуск программы

1. Убедитесь, что у вас установлен Python.
2. Скачайте файл `tsp_dfs_stack.py`.
3. Откройте терминал и выполните команду:
   ```bash
   python tsp_dfs_stack.py
   ```
4. Программа выведет минимальную длину пути и соответствующий маршрут.

### Пример вывода

```plaintext
Минимальная длина пути: 80
Кратчайший путь: [0, 1, 3, 2, 0]
```

## Пример матрицы смежности

Пример матрицы смежности графа:
```python
graph = [
    [0, 10, 15, 20],
    [10, 0, 35, 25],
    [15, 35, 0, 30],
    [20, 25, 30, 0]
]
```

Значение `graph[i][j]` — это вес ребра между узлами `i` и `j`. Если узлы не связаны, используйте значение `0`.

## Ограничения

- Код подходит для графов с малым числом узлов (до ~10-12), так как сложность алгоритма растёт экспоненциально.

## Дополнительно

Для улучшения производительности на больших графах рекомендуется использовать более эффективные алгоритмы, такие как:
- Алгоритм ветвей и границ
- Динамическое программирование (например, алгоритм Хелда-Карпа)
